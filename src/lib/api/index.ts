import createFetchClient from "openapi-fetch";
import createClient from "openapi-react-query";
import type { paths } from "./apigen"; // generated by openapi-typescript
import { createClient as createSupabaseClient } from '@supabase/supabase-js';
import { API_BASE_URL } from '@/lib/constants';

// Use constants for API base URL (empty string for relative paths with Vite proxy in production)
const API = API_BASE_URL;
const supabaseUrl = (process.env as any).VITE_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = (process.env as any).VITE_PUBLIC_SUPABASE_ANON_KEY;

// Minimal validation for environment variables
if (!supabaseUrl || !supabaseAnonKey) {
  console.error('‚ùå Missing Supabase environment variables (VITE_PUBLIC_SUPABASE_URL or VITE_PUBLIC_SUPABASE_ANON_KEY).');
}

// Debug: Verify env visibility (masked key)
try {
  // Only log in browser context to help diagnose runtime env loading
  if (typeof window !== 'undefined') {
    // eslint-disable-next-line no-console
    console.info('[Supabase Env]', {
      url: supabaseUrl,
      anonKeyPrefix: supabaseAnonKey ? `${supabaseAnonKey.slice(0, 8)}...` : null,
      anonKeyLength: supabaseAnonKey ? supabaseAnonKey.length : 0,
    });
  }
} catch {}

// Initialize Supabase if URL and key are available (API can be empty for proxy)
const supabase = supabaseUrl && supabaseAnonKey ? createSupabaseClient(supabaseUrl, supabaseAnonKey) : null;
if (!supabase) {
  console.error('‚ùå Failed to initialize Supabase client. Please check your .env variables.');
}

// Lightweight debug helper to inspect loaded Supabase env at runtime (browser only)
try {
  if (typeof window !== 'undefined') {
    (window as any).__SUPABASE_ENV__ = {
      url: supabaseUrl ?? null,
      anonKeyPrefix: supabaseAnonKey ? `${String(supabaseAnonKey).slice(0, 12)}...` : null,
      anonKeyLength: supabaseAnonKey ? String(supabaseAnonKey).length : 0,
      getAnonKey: () => supabaseAnonKey || null,
    };
  }
} catch {}

// Custom fetch function with auth headers
async function authedFetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
  if (!supabase) {
    // If supabase is not configured, just use regular fetch
    const headers = {
      'Content-Type': 'application/json',
      ...init?.headers
    };
    return fetch(input, { ...init, headers });
  }
  
  const { data } = await supabase.auth.getSession();
  const headers = {
    'Content-Type': 'application/json',
    ...(data.session?.access_token
      ? { Authorization: `Bearer ${data.session.access_token}` }
      : {}),
    ...init?.headers
  };

  return fetch(input, { ...init, headers });
}

// Create OpenAPI fetch client with authenticated fetch
export const fetchClient = createFetchClient<paths>({
  baseUrl: API,
  fetch: authedFetch,
});

// Create OpenAPI React Query client
export const $api = createClient(fetchClient);

// Enhanced apiFetch function with optional authentication
export async function apiFetch<T>(
  path: string,
  init: RequestInit & { auth?: boolean } = {}
): Promise<T> {
  const headers: Record<string, string> = { 
    'Content-Type': 'application/json', 
    ...(init.headers as Record<string, string> || {})
  };
  
  // Add auth header only if auth is not explicitly set to false (default = true)
  if (init.auth !== false && supabase) {
    const { data } = await supabase.auth.getSession();
    if (data.session) {
      headers.Authorization = `Bearer ${data.session.access_token}`;
    }
  }
  
  const res = await fetch(`${API}${path}`, { ...init, headers });
  if (!res.ok) throw new Error(await res.text());
  return res.json() as Promise<T>;
}

// NEW: Session-based API fetch function (replaces JWT Authorization headers)
export async function sessionApiFetch<T>(
  path: string,
  init: RequestInit & { sessionToken?: string | null; requireAuth?: boolean } = {}
): Promise<T> {
  const headers: Record<string, string> = { 
    'Content-Type': 'application/json', 
    ...(init.headers as Record<string, string> || {})
  };
  
  // Prepare request body with session token if provided
  let body = init.body;
  const { sessionToken, requireAuth = true, ...restInit } = init;
  
  // If session token is provided and we need auth, add it to request body
  if (sessionToken && requireAuth) {
    const existingBody = body ? JSON.parse(body as string) : {};
    body = JSON.stringify({
      ...existingBody,
      session_token: sessionToken
    });
  } else if (requireAuth && !sessionToken) {
    // Get session token from storage if not provided
    const storedToken = sessionStorage.getItem('workflow_session_token');
    if (storedToken) {
      const existingBody = body ? JSON.parse(body as string) : {};
      body = JSON.stringify({
        ...existingBody,
        session_token: storedToken
      });
    }
  }
  
  const res = await fetch(`${API}${path}`, { 
    ...restInit, 
    headers,
    body,
    method: init.method || 'POST' // Default to POST for session-based requests
  });
  
  if (!res.ok) {
    const errorText = await res.text();
    console.error(`üîê [API] Session API call failed: ${res.status} - ${errorText}`);
    throw new Error(errorText);
  }
  
  return res.json() as Promise<T>;
}

// Export the supabase client for use in other files
export { supabase };

export default $api;
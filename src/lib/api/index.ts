import createFetchClient from "openapi-fetch";
import createClient from "openapi-react-query";
import type { paths } from "./apigen"; // generated by openapi-typescript
import { createClient as createSupabaseClient } from '@supabase/supabase-js';

const API = import.meta.env.VITE_PUBLIC_API_URL;
const supabaseUrl = import.meta.env.VITE_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_PUBLIC_SUPABASE_ANON_KEY;
console.log(`Auth check:\n‚úÖ API: ${API}\n‚úÖ supabaseUrl: ${supabaseUrl}\n‚úÖ supabaseAnonKey: ${supabaseAnonKey}`);
const supabase = API && supabaseUrl && supabaseAnonKey ? createSupabaseClient(supabaseUrl, supabaseAnonKey) : null;
if (!supabase) {
  console.error("‚ùå failed to init Supabase client. Please check your .env variables.");
}

// Custom fetch function with auth headers
async function authedFetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
  const { data } = await supabase.auth.getSession();
  const headers = {
    'Content-Type': 'application/json',
    ...(data.session?.access_token
      ? { Authorization: `Bearer ${data.session.access_token}` }
      : {}),
    ...init?.headers
  };

  return fetch(input, { ...init, headers });
}

// Create OpenAPI fetch client with authenticated fetch
export const fetchClient = createFetchClient<paths>({
  baseUrl: API,
  fetch: authedFetch,
});

// Create OpenAPI React Query client
export const $api = createClient(fetchClient);

// Enhanced apiFetch function with optional authentication
export async function apiFetch<T>(
  path: string,
  init: RequestInit & { auth?: boolean } = {}
): Promise<T> {
  const headers: Record<string, string> = { 
    'Content-Type': 'application/json', 
    ...(init.headers as Record<string, string> || {})
  };
  
  // Add auth header only if auth is not explicitly set to false (default = true)
  if (init.auth !== false) {
    const { data } = await supabase.auth.getSession();
    if (data.session) {
      headers.Authorization = `Bearer ${data.session.access_token}`;
    }
  }
  
  const res = await fetch(`${API}${path}`, { ...init, headers });
  if (!res.ok) throw new Error(await res.text());
  return res.json() as Promise<T>;
}

// NEW: Session-based API fetch function (replaces JWT Authorization headers)
export async function sessionApiFetch<T>(
  path: string,
  init: RequestInit & { sessionToken?: string | null; requireAuth?: boolean } = {}
): Promise<T> {
  const headers: Record<string, string> = { 
    'Content-Type': 'application/json', 
    ...(init.headers as Record<string, string> || {})
  };
  
  // Prepare request body with session token if provided
  let body = init.body;
  const { sessionToken, requireAuth = true, ...restInit } = init;
  
  // If session token is provided and we need auth, add it to request body
  if (sessionToken && requireAuth) {
    const existingBody = body ? JSON.parse(body as string) : {};
    body = JSON.stringify({
      ...existingBody,
      session_token: sessionToken
    });
  } else if (requireAuth && !sessionToken) {
    // Get session token from storage if not provided
    const storedToken = sessionStorage.getItem('workflow_session_token');
    if (storedToken) {
      const existingBody = body ? JSON.parse(body as string) : {};
      body = JSON.stringify({
        ...existingBody,
        session_token: storedToken
      });
    }
  }
  
  const res = await fetch(`${API}${path}`, { 
    ...restInit, 
    headers,
    body,
    method: init.method || 'POST' // Default to POST for session-based requests
  });
  
  if (!res.ok) {
    const errorText = await res.text();
    console.error(`üîê [API] Session API call failed: ${res.status} - ${errorText}`);
    throw new Error(errorText);
  }
  
  return res.json() as Promise<T>;
}

export default $api;